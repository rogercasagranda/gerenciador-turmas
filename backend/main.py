# ======================================================
# Importa m√≥dulos padr√£o e terceiros
# ======================================================
import os                                   # Importa os recursos do sistema operacional para obter vari√°veis de ambiente
import logging                               # Importa o logging para registrar eventos e erros
from pathlib import Path                     # Importa Path para manipular caminhos de arquivos
import requests                               # Importa requests para realizar chamadas HTTP ao Google OAuth
import psycopg2                               # Importa psycopg2 para conex√£o s√≠ncrona com PostgreSQL
from psycopg2 import Error as PsycopgError    # Importa a classe de erro espec√≠fica do psycopg2

# ======================================================
# JWT: cria√ß√£o de token de acesso
# ======================================================
from datetime import datetime, timedelta     # Importa utilit√°rios de data e tempo
from jose import jwt                         # Importa biblioteca JOSE para gera√ß√£o de JWT

SECRET_KEY = os.getenv("JWT_SECRET_KEY", "change-me-in-prod")  # Define chave secreta do JWT
ALGORITHM = "HS256"                                             # Define algoritmo de assinatura
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("JWT_EXPIRE_MINUTES", "60"))  # Define expira√ß√£o padr√£o

def create_access_token(data: dict, expires_delta: timedelta | None = None):
    # Cria payload com expira√ß√£o
    to_encode = data.copy()                                                     # Copia dados de entrada
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))  # Calcula expira√ß√£o
    to_encode.update({"exp": expire})                                           # Insere expira√ß√£o no payload
    # Gera o token JWT
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)        # Codifica o token
    return encoded_jwt                                                          # Retorna o token

# ======================================================
# Importa FastAPI e utilidades
# ======================================================
from fastapi import FastAPI, Request, HTTPException, Depends   # Importa classes e fun√ß√µes da FastAPI
from fastapi.responses import RedirectResponse                  # Importa RedirectResponse para redirecionamentos
from fastapi.middleware.cors import CORSMiddleware              # Importa CORS middleware para liberar origens

# ======================================================
# Importa utilit√°rios de configura√ß√£o e modelos
# ======================================================
from dotenv import load_dotenv                 # Importa load_dotenv para carregar vari√°veis do arquivo .env
from pydantic import BaseModel, Field, ConfigDict  # Importa BaseModel, Field e ConfigDict para valida√ß√£o flex√≠vel

# ======================================================
# Importa camada de acesso a dados (AJUSTE DE IMPORTS PARA EXECUTAR PELA RAIZ)
# ======================================================
from backend.database import get_db                    # Importa fun√ß√£o get_db via pacote absoluto
from backend.models.usuarios import Usuarios           # Importa o modelo Usuarios via pacote absoluto
import bcrypt                                          # Importa bcrypt para valida√ß√£o de senha

# ======================================================
# IMPORTA ROTAS (MERGE) ‚Äî adiciona router de usu√°rios
# ======================================================
from backend.routes.usuarios import router as usuarios_router   # Importa router de /usuarios

# ======================================================
# Configura logger da aplica√ß√£o
# ======================================================
logging.basicConfig(level=logging.INFO)        # Define n√≠vel de log como INFO
logger = logging.getLogger(__name__)           # Cria inst√¢ncia de logger para este m√≥dulo

# ======================================================
# Carrega vari√°veis do arquivo .env localizado em backend/.env
# ======================================================
env_path = Path(__file__).resolve().parent / ".env"  # Define caminho absoluto do .env na pasta backend
load_dotenv(dotenv_path=env_path)                    # Carrega as vari√°veis do .env

# ======================================================
# Instancia aplica√ß√£o FastAPI
# ======================================================
app = FastAPI()                                      # Cria inst√¢ncia principal do app FastAPI

# ======================================================
# Configura CORS de forma ampla (padr√£o j√° aprovado)
# ======================================================
app.add_middleware(                                  # Adiciona middleware de CORS
    CORSMiddleware,                                  # Define a classe do middleware
    allow_origins=["*"],                             # Libera origens
    allow_credentials=True,                          # Permite envio de cookies/credenciais
    allow_methods=["*"],                             # Libera todos os m√©todos HTTP
    allow_headers=["*"],                             # Libera todos os headers
)

# ======================================================
# Registra routers (MERGE) ‚Äî mant√©m existentes e soma /usuarios
# ======================================================
app.include_router(usuarios_router)                  # Registra rotas de usu√°rios (/usuarios GET/POST)

# ======================================================
# Loga vari√°veis p√∫blicas do OAuth (sem expor segredos)
# ======================================================
logger.info(f"üîé GOOGLE_CLIENT_ID: {os.getenv('GOOGLE_CLIENT_ID')}")         # Registra o client_id para confer√™ncia
logger.info(f"üîé GOOGLE_REDIRECT_URI: {os.getenv('GOOGLE_REDIRECT_URI')}")   # Registra a redirect_uri para confer√™ncia

# ======================================================
# Exibe rotas ao iniciar o servidor
# ======================================================
@app.on_event("startup")                     # Define tarefa a executar no start do app
async def startup_event():                   # Declara fun√ß√£o ass√≠ncrona de inicializa√ß√£o
    logger.info("‚úÖ Backend iniciado com sucesso")     # Registra mensagem de inicializa√ß√£o
    logger.info("‚úÖ Rotas registradas:")               # Registra cabe√ßalho das rotas
    for route in app.routes:                           # Itera sobre rotas registradas
        logger.info(f"‚û°Ô∏è {route.path}")                # Registra caminho de cada rota

# ======================================================
# Modelo de payload com alias para compatibilizar o front
# ======================================================
class LoginPayload(BaseModel):                                       # Declara classe Pydantic para login
    email: str | None = Field(default=None, alias="usuario")         # Aceita 'usuario' como alias de 'email'
    senha: str | None = Field(default=None, alias="password")        # Aceita 'password' como alias de 'senha'
    model_config = ConfigDict(populate_by_name=True, extra="ignore") # Permite popular por nome e ignora extras

# ======================================================
# Rota de login: aceita JSON e form-data, mapeia aliases
# ======================================================
@app.post("/login")                                                  # Define endpoint POST /login
async def login(request: Request, db=Depends(get_db)):               # Declara fun√ß√£o com inje√ß√£o de sess√£o do DB
    content_type = request.headers.get("content-type", "")           # Obt√©m o Content-Type da requisi√ß√£o

    # --------------------------------------------------
    # L√™ o corpo conforme o tipo enviado pelo front
    # --------------------------------------------------
    if "application/json" in content_type:                           # Verifica se √© JSON
        raw = await request.json()                                   # L√™ o JSON do corpo
    else:                                                            # Caso contr√°rio, trata como form-data
        form = await request.form()                                  # L√™ o formul√°rio enviado
        raw = dict(form)                                             # Converte em dicion√°rio simples

    # --------------------------------------------------
    # Normaliza chaves aceitando varia√ß√µes do front
    # --------------------------------------------------
    email = (raw.get("email") or raw.get("usuario") or raw.get("username") or "").strip()  # Normaliza e-mail
    senha = (raw.get("senha") or raw.get("password") or "").strip()                        # Normaliza senha

    # --------------------------------------------------
    # Valida√ß√£o m√≠nima do payload
    # --------------------------------------------------
    if not email or not senha:                                       # Verifica se faltam campos
        logger.warning("‚ö†Ô∏è Payload inv√°lido no /login (faltando email/senha)")             # Registra aviso
        raise HTTPException(status_code=422, detail="Payload inv√°lido: envie 'email' e 'senha'.")  # Retorna 422

    logger.info(f"üîç Tentativa de login com e-mail: {email}")         # Registra tentativa de login

    # --------------------------------------------------
    # Consulta usu√°rio via ORM
    # --------------------------------------------------
    usuario = db.query(Usuarios).filter(Usuarios.email == email).first()  # Busca usu√°rio por e-mail
    if not usuario:                                                       # Verifica inexist√™ncia
        logger.warning(f"‚õî Usu√°rio n√£o pr√©-cadastrado (LOCAL): {email}")  # Registra pr√©-cadastro ausente
        from fastapi.responses import JSONResponse                         # Importa resposta JSON espec√≠fica
        return JSONResponse(                                               # Retorna 403 com c√≥digo e mensagem
            status_code=403,
            content={"code": "USER_NOT_FOUND", "message": "Cadastro n√£o encontrado, procure a secretaria da sua escola"}
        )

    # --------------------------------------------------
    # Valida senha com bcrypt
    # --------------------------------------------------
    if not bcrypt.checkpw(senha.encode("utf-8"), usuario.senha_hash.encode("utf-8")):  # Compara hash
        logger.warning(f"‚ùå Senha incorreta para o e-mail: {email}")                     # Registra senha incorreta
        raise HTTPException(                                                            # Retorna 401 padronizado
            status_code=401,
            detail="SEU USU√ÅRIO E/OU SENHA EST√ÉO INCORRETAS, TENTE NOVAMENTE"
        )

    # --------------------------------------------------
    # Sucesso
    # --------------------------------------------------
    logger.info(f"‚úÖ Login realizado com sucesso para: {email}")       # Registra sucesso
    # Gera JWT incluindo identificador e tipo de perfil do usu√°rio
    token_payload = {
        "sub": email,
        "id_usuario": usuario.id_usuario,
        "tipo_perfil": usuario.tipo_perfil,
    }
    token = create_access_token(token_payload)
    return {
        "message": "Login realizado com sucesso",
        "token": token,
        "email": email,
        "id_usuario": usuario.id_usuario,
        "tipo_perfil": usuario.tipo_perfil,
    }  # Retorna token e dados b√°sicos do usu√°rio

# ======================================================
# (As rotas /google-login e /google-callback permanecem como no seu c√≥digo aprovado)
# ======================================================

# üîì Google login
@app.get("/google-login")
def google_login():
    client_id = os.getenv("GOOGLE_CLIENT_ID")                          # L√™ client_id do .env
    redirect_uri = os.getenv("GOOGLE_REDIRECT_URI")                    # L√™ redirect_uri do .env
    scope = "openid%20email%20profile"                                 # Define escopos solicitados
    google_oauth_url = (                                               # Monta URL de autoriza√ß√£o
        f"https://accounts.google.com/o/oauth2/v2/auth"
        f"?client_id={client_id}"
        f"&response_type=code"
        f"&redirect_uri={redirect_uri}"
        f"&scope={scope}"
        f"&access_type=offline"
        f"&prompt=consent"
    )
    return RedirectResponse(google_oauth_url)                          # Redireciona para Google

# üîÅ Google callback
@app.get("/google-callback")
def google_callback(request: Request):
    try:
        code = request.query_params.get("code")                        # L√™ c√≥digo de autoriza√ß√£o
        if not code:                                                   # Valida presen√ßa do c√≥digo
            raise HTTPException(status_code=400, detail="C√≥digo de autoriza√ß√£o ausente")  # Retorna 400

        client_id = os.getenv("GOOGLE_CLIENT_ID")                      # L√™ client_id do .env
        client_secret = os.getenv("GOOGLE_CLIENT_SECRET")              # L√™ client_secret do .env
        redirect_uri = os.getenv("GOOGLE_REDIRECT_URI")                # L√™ redirect_uri do .env

        token_url = "https://oauth2.googleapis.com/token"              # Define endpoint de token
        token_data = {                                                 # Monta payload de troca de c√≥digo
            "code": code,
            "client_id": client_id,
            "client_secret": client_secret,
            "redirect_uri": redirect_uri,
            "grant_type": "authorization_code",
        }

        token_response = requests.post(token_url, data=token_data, timeout=10)  # Solicita token ao Google
        if token_response.status_code != 200:                                   # Valida resposta
            logger.error(f"‚ùå Erro ao obter token: {token_response.text}")      # Registra erro
            raise HTTPException(status_code=400, detail="Falha ao obter token de acesso")  # Retorna 400

        access_token = token_response.json().get("access_token")      # Extrai access_token
        if not access_token:                                          # Valida presen√ßa
            raise HTTPException(status_code=400, detail="Token de acesso ausente")  # Retorna 400

        user_info_url = "https://www.googleapis.com/oauth2/v1/userinfo"  # Define endpoint de userinfo
        headers = {"Authorization": f"Bearer {access_token}"}            # Monta header de autoriza√ß√£o
        user_info_response = requests.get(user_info_url, headers=headers, timeout=10)  # Consulta dados do usu√°rio
        if user_info_response.status_code != 200:                        # Valida resposta
            logger.error(f"‚ùå Erro ao obter dados do usu√°rio: {user_info_response.text}")  # Registra erro
            raise HTTPException(status_code=400, detail="Erro ao obter dados do usu√°rio")  # Retorna 400

        user_data = user_info_response.json()                # Converte resposta para dicion√°rio
        user_email = user_data.get("email")                  # Extrai e-mail do usu√°rio
        if not user_email:                                   # Valida presen√ßa do e-mail
            raise HTTPException(status_code=400, detail="Email n√£o encontrado na resposta do Google")  # Retorna 400

        conn = None                                          # Inicializa conex√£o
        cur = None                                           # Inicializa cursor
        try:
            database_url = os.getenv("DATABASE_URL")         # L√™ URL do banco
            conn = psycopg2.connect(dsn=database_url)        # Abre conex√£o
            cur = conn.cursor()                              # Abre cursor
            cur.execute("SELECT id_usuario FROM usuarios WHERE email = %s", (user_email,))  # Consulta pr√©-cadastro
            result = cur.fetchone()                          # L√™ resultado

            if not result:                                   # Verifica se usu√°rio n√£o existe
                logger.warning(f"‚õî Usu√°rio n√£o pr√©-cadastrado (GOOGLE): {user_email}")  # Registra aus√™ncia
                from fastapi.responses import RedirectResponse                            # Importa RedirectResponse
                frontend_url = os.getenv("FRONTEND_URL", "http://localhost:5173")        # Define URL do front
                return RedirectResponse(url=f"{frontend_url}/login?err=USER_NOT_FOUND", status_code=302)  # Redireciona

            logger.info(f"‚úÖ Usu√°rio autorizado: {user_email}")    # Registra sucesso
            token = create_access_token({"sub": user_email})       # Gera JWT
            from fastapi.responses import RedirectResponse         # Importa RedirectResponse
            frontend_url = os.getenv("FRONTEND_URL", "http://localhost:5173")  # Define URL do front
            return RedirectResponse(url=f"{frontend_url}/login?token={token}", status_code=302)  # Redireciona com token

        except PsycopgError as db_err:                       # Captura erro de banco
            logger.error(f"‚ùå Erro ao consultar banco de dados: {db_err}")  # Registra erro
            raise HTTPException(status_code=500, detail="Erro ao acessar banco de dados")  # Retorna 500
        finally:
            if cur is not None:                              # Verifica cursor aberto
                try:
                    cur.close()                              # Fecha cursor
                except Exception:
                    logger.warning("‚ö†Ô∏è Falha ao fechar cursor do banco")   # Registra aviso
            if conn is not None:                             # Verifica conex√£o aberta
                try:
                    conn.close()                             # Fecha conex√£o
                except Exception:
                    logger.warning("‚ö†Ô∏è Falha ao fechar conex√£o com o banco")  # Registra aviso

    except HTTPException:                                    # Mant√©m HTTPException original
        raise                                                # Propaga exce√ß√£o
    except Exception:                                        # Captura exce√ß√µes n√£o previstas
        logger.exception("‚ùå Erro inesperado na callback do Google")  # Registra stacktrace
        raise HTTPException(status_code=500, detail="Erro interno no servidor")  # Retorna 500
